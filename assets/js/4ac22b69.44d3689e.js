"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[362],{5615:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=t(4596),r=t(4848),s=t(8453);const a={title:"(Un)ordinary type-fu in Haskell",tags:["haskell","fp","generics"]},l="(Un)ordinary type-fu in Haskell",o={authorsImageUrls:[]},c=[{value:"Motivating example",id:"motivating-example",level:2},{value:"What GHC.Generic&#39;s do under the hood",id:"what-ghcgenerics-do-under-the-hood",level:2},{value:"Part 2: Higher Kinded Data Types",id:"part-2-higher-kinded-data-types",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"I'm progressing with my learning of Haskell. After grasping basic concepts time has come\nto face more challenging stuff."}),"\n",(0,r.jsx)(n.p,{children:'There are several "patterns" on the intermediate level and all make heavy use of types. The\ntennets are to reduce typing and making more generalized abstractions. They come at cost\nof upfront learning time and are hard to grasp really.'}),"\n",(0,r.jsxs)(n.p,{children:["This time I tackled 2 topics: ",(0,r.jsx)(n.strong,{children:"structural pattern"})," and then ",(0,r.jsx)(n.strong,{children:"generics"}),". I managed to\ncombine these two in one post, so I will share it today."]}),"\n",(0,r.jsx)(n.h2,{id:"motivating-example",children:"Motivating example"}),"\n",(0,r.jsx)(n.p,{children:"So let's start with something simple. You want to model complex numbers with a datatype. Like for\nexample:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"data Pair = MkPair {\n    first :: Int,\n    second :: Int\n}\n    deriving (Show, Eq)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["What is immediately obvious is that if you wanted to have ",(0,r.jsx)(n.em,{children:"Pair"})," for ",(0,r.jsx)(n.em,{children:"Double"})," then you would\nhave to write duplicate record definition. Better to generalize to all numbers:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"data (Num f) => Pair f = MkPair {\n    first :: f,\n    second :: f\n}\n    deriving (Show, Eq)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Because we are interested only numerical values we limit ",(0,r.jsx)(n.code,{children:"f"})," to the types instantiating ",(0,r.jsx)(n.code,{children:"Num"})," type class:\n",(0,r.jsx)(n.code,{children:"(Num f) => Pair f = MkPair"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"But then you realize that you also need a class for complex numbers."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"data (Num f) => Complex f = MkComplex {\n    real :: f,\n    imag :: f\n}\n    deriving (Show, Eq)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It is almost identical but carries different meaning. That's actually good that Haskell type\nsystem is ",(0,r.jsx)(n.strong,{children:"nominal"})," (new name means new type)."]}),"\n",(0,r.jsxs)(n.p,{children:["But these types are identical regarding the structure. What if we could actually compare ",(0,r.jsx)(n.code,{children:"Pair"}),"\nand ",(0,r.jsx)(n.code,{children:"Complex"})," with the same method?"]}),"\n",(0,r.jsx)(n.h2,{id:"what-ghcgenerics-do-under-the-hood",children:"What GHC.Generic's do under the hood"}),"\n",(0,r.jsx)(n.p,{children:"To simulate (and duplicate) functionality in GHC itself we will implement the mechanism for\njust one specific case. We start by implementing typeclass that is an interface for extracting\ngeneric structure."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"class Generic a where\n    type Rep a :: Type\n    from :: a -> Rep a\n    to :: Rep a -> a\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Generic"})," typeclass has ",(0,r.jsx)(n.strong,{children:"associated type"}),' that each instance will implement. This type is\nour "structure". ',(0,r.jsx)(n.code,{children:"Rep a"})," is connocalized type and ",(0,r.jsx)(n.code,{children:"to"})," and ",(0,r.jsx)(n.code,{children:"from"})," methods convert back and forth."]}),"\n",(0,r.jsx)(n.p,{children:"Then each type that want's the representation canonicalized will have to implement it. We can\ndo it for your two types."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"instance (Num f) => Generic (Complex f) where\n    type Rep (Complex f) = (f, f)\n    from (MkComplex r i) = (r, i)\n    to (r, i) = MkComplex r i\n\ninstance (Num f) => Generic (Pair f) where\n    type Rep (Pair f) = (f, f)\n    from (MkPair r i) = (r, i)\n    to (r, i) = MkPair r i\n"})}),"\n",(0,r.jsx)(n.p,{children:'As you can see for both types we "strip off" data type and represent it as plain product type = tuple.'}),"\n",(0,r.jsxs)(n.p,{children:["Then how do we approch equality checking? We implement generalized version ",(0,r.jsx)(n.code,{children:"geq"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"geq :: (Generic a, Generic b, Rep a ~ Rep b, Eq (Rep a)) => a -> b -> Bool\ngeq x y = from x == from y\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["So our function ",(0,r.jsx)(n.code,{children:"geq"})," requires that (of course) type is implementing ",(0,r.jsx)(n.code,{children:"Generic"})," type class.\nThen this is interesting:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Rep a ~ Rep b, Eq (Rep a)"})," - we limit function to compare only those generic instances that have\nequal representation types (ie. (,))"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"geq x y = from x == from y"})," - compare representations"]}),"\n",(0,r.jsx)(n.p,{children:"Let's check:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"ghci> :{\nghci| let x = MkComplex { real = 1, imag = 1}\nghci|     y = MkPair { first = 1, second = 1}\nghci| in x `geq` y\nghci| :}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"True\n"})}),"\n",(0,r.jsx)(n.p,{children:"And other one:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"ghci> :{\nghci| let x = MkPair { first = 1.0, second = 1.0 }\nghci|     y = MkComplex { real = 2.0, imag = 2.0 }\nghci| in x `geq` y\nghci| :}\n\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"False\n"})}),"\n",(0,r.jsx)(n.h2,{id:"part-2-higher-kinded-data-types",children:"Part 2: Higher Kinded Data Types"}),"\n",(0,r.jsx)(n.p,{children:'We will learn here structural pattern for reading in and validating forms. It makes heavy use of\nApplicative and the fact that we can "curry" generated constructor for a record.'}),"\n",(0,r.jsx)(n.p,{children:'The idea of HKD is simple - parametrize type by "container", ie.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"data  Person f = MkPerson {\n    firstName :: f String,\n    lastName :: f String,\n    age :: f Int\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"What does it gives us? Let's see the type of constructor:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"ghci> :t MkPerson\nMkPerson :: f String -> f String -> f Int -> Person f\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If f is an ",(0,r.jsx)(n.code,{children:"Applicative"})," and most usually it is we can use ",(0,r.jsx)(n.code,{children:"<*>"})," curry each step of\nconstructor operating on record fields."]}),"\n",(0,r.jsx)(n.p,{children:"Let's read in the data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'readString :: IO (Maybe String)\nreadString = do\n    str <- fmap strip getLine\n    return $ case str of\n        "" -> Nothing\n        _ -> Just str\n\nreadInt :: IO (Maybe Int)\nreadInt = do\n    s <- readString\n    return $ s >>= readMaybe\n\n\nreadPerson :: IO (Person Maybe)\nreadPerson = MkPerson\n    <$> readString\n    <*> readString\n    <*> readInt\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The logic is simple: in case of string if is empty string return ",(0,r.jsx)(n.code,{children:"Nothing"})," and in case\nof int unparsable number gives ",(0,r.jsx)(n.code,{children:"Nothing"})," as well. So we used ",(0,r.jsx)(n.strong,{children:"structural pattern"})," for the first\ntime. At each step reading function is applied so constituents ",(0,r.jsx)(n.code,{children:"IO (Maybe String)"})," and ",(0,r.jsx)(n.code,{children:"IO (Maybe Int)"}),"\nget turned into ",(0,r.jsx)(n.code,{children:"IO (Person Maybe)"})," eventually."]}),"\n",(0,r.jsx)(n.p,{children:"Then we would like the following: if some field is nothing apply the defaults instead."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"defaults :: Person Maybe\ndefaults = MkPerson {\n    firstName = Just \"John\",\n    lastName = Just \"Doe\",\n    age = Just 30\n}\n\napplyDefaults :: IO (Person Maybe) -> IO (Maybe (Person Identity))\napplyDefaults p = do\n    p' <- p\n    return (MkPerson\n        <$> fmap Identity (firstName p' <|> firstName defaults)\n        <*> fmap Identity (lastName p' <|> lastName defaults)\n        <*> fmap Identity (age p' <|> age defaults))\n"})}),"\n",(0,r.jsx)(n.p,{children:"If we run for example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'ghci> let p = MkPerson {firstName = (Just "Dominik"), lastName = (Just "Gawlik"), age = (Just 34)}\nghci> fmap Identity (firstName p)\nJust (Identity {runIdentity = "Dominik"})\n'})}),"\n",(0,r.jsx)(n.p,{children:"We can see that it flips Maybe with Idenity in a smart way."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"We extract the Maybe from the record by autogenerated field-method"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fmap"})," applies ",(0,r.jsx)(n.code,{children:"Identity"})," constructor inside ",(0,r.jsx)(n.code,{children:"Maybe"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["So basically what we did with the above code is that we ascertain that all the fields\nare ",(0,r.jsx)(n.code,{children:"Maybe"}),"'s ",(0,r.jsx)(n.code,{children:"Just"})," other way around we would get nothing."]}),"\n",(0,r.jsx)(n.p,{children:"So the last step is to serialize the record into something with similar structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"data PersonFinal = MkPersonFinal {\n    firstName' :: String,\n    lastName' :: String,\n    age' :: Int\n}\n    deriving (Show)\n\nserialize :: Person Identity -> PersonFinal\nserialize p = MkPersonFinal {\n    firstName' = runIdentity (firstName p),\n    lastName' = runIdentity (lastName p),\n    age' = runIdentity (age p)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now let's test it."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"runIO = do\n    p <- applyDefaults readPerson\n    print $ fmap serialize p\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'ghci> runIO\n\ngawlik\n\nJust (MkPersonFinal {firstName\' = "John", lastName\' = "gawlik", age\' = 30})\n'})}),"\n",(0,r.jsx)(n.p,{children:"And we get what we wanted."}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Structural pattern is intemediate-level Haskell code that comes in handy. It is useful to know about\nit if you will read some packages in the future. We touched Higher Kinded Data Types and some typing\nticks to make generics work similar way to GHC."}),"\n",(0,r.jsx)(n.p,{children:"Reading:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://reasonablypolymorphic.com/blog/higher-kinded-data/",children:"Reasonably Polymorphic on HKD"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.youtube.com/watch?v=pwnrfREbhWY",children:"Generics in depth"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.microsoft.com/en-us/research/wp-content/uploads/2008/01/icfp2008.pdf",children:"Type Families (not mentioned here)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://chrispenner.ca/posts/hkd-options",children:"Chris Penner on forms in Haskell"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Thanks."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},4596:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/03/16/","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-03-16.md","source":"@site/blog/2025-03-16.md","title":"(Un)ordinary type-fu in Haskell","description":"I\'m progressing with my learning of Haskell. After grasping basic concepts time has come","date":"2025-03-16T00:00:00.000Z","tags":[{"inline":true,"label":"haskell","permalink":"/blog/tags/haskell"},{"inline":true,"label":"fp","permalink":"/blog/tags/fp"},{"inline":true,"label":"generics","permalink":"/blog/tags/generics"}],"readingTime":6.155,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"(Un)ordinary type-fu in Haskell","tags":["haskell","fp","generics"]},"unlisted":false,"nextItem":{"title":"Semantic search for dynamically built queries in Java and CodeQL","permalink":"/blog/2025/03/9/"}}')}}]);